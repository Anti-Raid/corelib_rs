use async_trait::async_trait;
use splashcore_rs::value::Value;
use std::sync::Arc;

pub type Error = Box<dyn std::error::Error + Send + Sync>; // This is constant and should be copy pasted

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum SettingsError {
    /// Operation not supported
    OperationNotSupported {
        operation: OperationType,
    },
    /// Generic error
    Generic {
        message: String,
        src: String,
        typ: String,
    },
    /// Schema type validation error
    SchemaTypeValidationError {
        column: String,
        expected_type: String,
        got_type: String,
    },
    /// Schema null value validation error
    SchemaNullValueValidationError {
        column: String,
    },
    /// Schema check validation error
    SchemaCheckValidationError {
        column: String,
        check: String,
        error: String,
        accepted_range: String,
    },
    /// Missing or invalid field
    MissingOrInvalidField {
        field: String,
        src: String,
    },
    RowExists {
        column_id: String,
        count: i64,
    },
    RowDoesNotExist {
        column_id: String,
    },
    MaximumCountReached {
        max: usize,
        current: usize,
    },
    PermissionError {
        result: permissions::types::PermissionResult,
    },
}

pub struct SettingsData {
    pub pool: sqlx::PgPool,
    pub reqwest: reqwest::Client,
    pub object_store: Arc<splashcore_rs::objectstore::ObjectStore>,
    pub cache_http: botox::cache::CacheHttpImpl,
    pub serenity_context: serenity::all::Context,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[allow(dead_code)]
pub enum ColumnType {
    /// A single valued column (scalar)
    Scalar {
        /// The value type
        inner: InnerColumnType,
    },
    /// An array column
    Array {
        /// The inner type of the array
        inner: InnerColumnType,
    },
}

impl ColumnType {
    /// Returns whether the column type is an array
    #[allow(dead_code)]
    pub fn is_array(&self) -> bool {
        matches!(self, ColumnType::Array { .. })
    }

    /// Returns whether the column type is a scalar
    #[allow(dead_code)]
    pub fn is_scalar(&self) -> bool {
        matches!(self, ColumnType::Scalar { .. })
    }

    pub fn new_scalar(inner: InnerColumnType) -> Self {
        ColumnType::Scalar { inner }
    }

    pub fn new_array(inner: InnerColumnType) -> Self {
        ColumnType::Array { inner }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[allow(dead_code)]
pub enum InnerColumnTypeStringKind {
    /// Normal string
    Normal {},
    /// A token that is autogenerated if not provided by the user
    Token {
        /// The default length of the secret if not provided by the user
        default_length: usize,
    },
    /// A textarea
    Textarea { ctx: String },
    /// A reference to a template by name
    TemplateRef {},
    /// A kittycat permission
    KittycatPermission {},
    /// User
    User {},
    /// Role
    Role {},
    /// Channel selector
    Channel {
        needed_bot_permissions: serenity::all::Permissions,
        allowed_channel_types: Vec<serenity::all::ChannelType>,
    },
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[allow(dead_code)]
pub enum InnerColumnType {
    Uuid {},
    String {
        min_length: Option<usize>,
        max_length: Option<usize>,
        allowed_values: Vec<String>, // If empty, all values are allowed
        kind: InnerColumnTypeStringKind,
    },
    Timestamp {},
    TimestampTz {},
    Interval {},
    Integer {},
    Float {},
    BitFlag {
        /// The bit flag values
        values: indexmap::IndexMap<String, i64>,
    },
    Boolean {},
    Json {
        max_bytes: Option<usize>,
    },
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
pub enum ColumnSuggestion {
    Static { suggestions: Vec<String> },
    None {},
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Column {
    /// The ID of the column on the database
    pub id: String,

    /// The friendly name of the column
    pub name: String,

    /// The description of the column
    pub description: String,

    /// The type of the column
    pub column_type: ColumnType,

    /// Whether or not the column is nullable
    ///
    /// Note that the point where nullability is checked may vary but will occur after pre_checks are executed
    pub nullable: bool,

    /// Suggestions to display
    pub suggestions: ColumnSuggestion,

    /// A secret field that is not shown to the user
    pub secret: bool,

    /// For which operations should the field be ignored for (essentially, read only)
    ///
    /// Semantics are defined by the Executor
    pub ignored_for: Vec<OperationType>,
}

impl PartialEq for Column {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Hash, Eq, serde::Serialize, serde::Deserialize)]
#[allow(dead_code)]
pub enum OperationType {
    View,
    Create,
    Update,
    Delete,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Setting {
    /// The ID of the option
    pub id: String,

    /// The name of the option
    pub name: String,

    /// The description of the option
    pub description: String,

    /// The primary key of the table. Should be present in ID
    pub primary_key: String,

    /// Title template, used for the title of the embed
    pub title_template: String,

    /// The columns for this option
    pub columns: Arc<Vec<Column>>,

    /// The supported operations for this option
    #[serde(skip_deserializing)]
    pub operations: SettingOperations,
}

#[derive(Clone, Default)]
pub struct SettingOperations {
    /// How to view this setting
    pub view: Option<Arc<dyn SettingView>>,

    /// How to create this setting
    pub create: Option<Arc<dyn SettingCreator>>,

    /// How to update this setting
    pub update: Option<Arc<dyn SettingUpdater>>,

    /// How to delete this setting
    pub delete: Option<Arc<dyn SettingDeleter>>,
}

impl std::fmt::Debug for SettingOperations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SettingOperations")
    }
}

impl serde::Serialize for SettingOperations {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut supported_operations = Vec::new();

        if let Some(_v) = &self.view {
            supported_operations.push(OperationType::View);
        }

        if let Some(_v) = &self.create {
            supported_operations.push(OperationType::Create);
        }

        if let Some(_v) = &self.update {
            supported_operations.push(OperationType::Update);
        }

        if let Some(_v) = &self.delete {
            supported_operations.push(OperationType::Delete);
        }

        supported_operations.serialize(serializer)
    }
}

impl PartialEq for Setting {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

/// Wraps `v` in the currently used wrapper
///
/// Currently, this is an Arc for now
pub fn settings_wrap<T>(v: T) -> Arc<T> {
    Arc::new(v)
}

/// This is the context provided to all hooks (post-actions, validators, etc.)
#[allow(dead_code)]
pub struct HookContext<'a> {
    pub author: serenity::all::UserId,
    pub guild_id: serenity::all::GuildId,
    pub data: &'a SettingsData, // The data object
}

#[async_trait]
pub trait SettingView: Send + Sync {
    /// View the settings data
    ///
    /// All Executors should return an __count value containing the total count of the total number of entries
    async fn view<'a>(
        &self,
        context: HookContext<'a>,
        filters: indexmap::IndexMap<String, splashcore_rs::value::Value>,
    ) -> Result<Vec<indexmap::IndexMap<String, Value>>, SettingsError>;
}

#[async_trait]
pub trait SettingCreator: Send + Sync {
    /// Creates the setting
    async fn create<'a>(
        &self,
        context: HookContext<'a>,
        state: indexmap::IndexMap<String, Value>,
    ) -> Result<indexmap::IndexMap<String, Value>, SettingsError>;
}

#[async_trait]
pub trait SettingUpdater: Send + Sync {
    /// Updates the setting
    async fn update<'a>(
        &self,
        context: HookContext<'a>,
        state: indexmap::IndexMap<String, Value>,
    ) -> Result<indexmap::IndexMap<String, Value>, SettingsError>;
}

#[async_trait]
pub trait SettingDeleter: Send + Sync {
    /// Deletes the setting
    async fn delete<'a>(
        &self,
        context: HookContext<'a>,
        pkey: splashcore_rs::value::Value,
    ) -> Result<(), SettingsError>;
}

impl<T: SettingView + SettingCreator + SettingUpdater + SettingDeleter + Clone + 'static> From<T>
    for SettingOperations
{
    fn from(v: T) -> Self {
        SettingOperations {
            view: Some(settings_wrap(v.clone())),
            create: Some(settings_wrap(v.clone())),
            update: Some(settings_wrap(v.clone())),
            delete: Some(settings_wrap(v)),
        }
    }
}

#[allow(dead_code)]
impl SettingOperations {
    pub fn to_view_op<T: SettingView + Clone + 'static>(v: T) -> Self {
        SettingOperations {
            view: Some(settings_wrap(v)),
            create: None,
            update: None,
            delete: None,
        }
    }

    pub fn to_create_op<T: SettingCreator + Clone + 'static>(v: T) -> Self {
        SettingOperations {
            view: None,
            create: Some(settings_wrap(v)),
            update: None,
            delete: None,
        }
    }

    pub fn to_update_op<T: SettingUpdater + Clone + 'static>(v: T) -> Self {
        SettingOperations {
            view: None,
            create: None,
            update: Some(settings_wrap(v)),
            delete: None,
        }
    }

    pub fn to_delete_op<T: SettingDeleter + Clone + 'static>(v: T) -> Self {
        SettingOperations {
            view: None,
            create: None,
            update: None,
            delete: Some(settings_wrap(v)),
        }
    }

    pub fn to_view_create_op<T: SettingView + SettingCreator + Clone + 'static>(v: T) -> Self {
        SettingOperations {
            view: Some(settings_wrap(v.clone())),
            create: Some(settings_wrap(v)),
            update: None,
            delete: None,
        }
    }

    pub fn to_view_update_op<T: SettingView + SettingUpdater + Clone + 'static>(v: T) -> Self {
        SettingOperations {
            view: Some(settings_wrap(v.clone())),
            create: None,
            update: Some(settings_wrap(v)),
            delete: None,
        }
    }

    pub fn to_view_delete_op<T: SettingView + SettingDeleter + Clone + 'static>(v: T) -> Self {
        SettingOperations {
            view: Some(settings_wrap(v.clone())),
            create: None,
            update: None,
            delete: Some(settings_wrap(v)),
        }
    }

    pub fn to_create_update_op<T: SettingCreator + SettingUpdater + Clone + 'static>(v: T) -> Self {
        SettingOperations {
            view: None,
            create: Some(settings_wrap(v.clone())),
            update: Some(settings_wrap(v)),
            delete: None,
        }
    }

    pub fn to_create_delete_op<T: SettingCreator + SettingDeleter + Clone + 'static>(v: T) -> Self {
        SettingOperations {
            view: None,
            create: Some(settings_wrap(v.clone())),
            update: None,
            delete: Some(settings_wrap(v)),
        }
    }

    pub fn to_update_delete_op<T: SettingUpdater + SettingDeleter + Clone + 'static>(v: T) -> Self {
        SettingOperations {
            view: None,
            create: None,
            update: Some(settings_wrap(v.clone())),
            delete: Some(settings_wrap(v)),
        }
    }

    pub fn to_view_create_update_op<
        T: SettingView + SettingCreator + SettingUpdater + Clone + 'static,
    >(
        v: T,
    ) -> Self {
        SettingOperations {
            view: Some(settings_wrap(v.clone())),
            create: Some(settings_wrap(v.clone())),
            update: Some(settings_wrap(v)),
            delete: None,
        }
    }

    pub fn to_view_create_delete_op<
        T: SettingView + SettingCreator + SettingDeleter + Clone + 'static,
    >(
        v: T,
    ) -> Self {
        SettingOperations {
            view: Some(settings_wrap(v.clone())),
            create: Some(settings_wrap(v.clone())),
            update: None,
            delete: Some(settings_wrap(v)),
        }
    }

    pub fn to_view_update_delete_op<
        T: SettingView + SettingUpdater + SettingDeleter + Clone + 'static,
    >(
        v: T,
    ) -> Self {
        SettingOperations {
            view: Some(settings_wrap(v.clone())),
            create: None,
            update: Some(settings_wrap(v.clone())),
            delete: Some(settings_wrap(v)),
        }
    }

    pub fn to_create_update_delete_op<
        T: SettingCreator + SettingUpdater + SettingDeleter + Clone + 'static,
    >(
        v: T,
    ) -> Self {
        SettingOperations {
            view: None,
            create: Some(settings_wrap(v.clone())),
            update: Some(settings_wrap(v.clone())),
            delete: Some(settings_wrap(v)),
        }
    }

    pub fn to_view_create_update_delete_op<
        T: SettingView + SettingCreator + SettingUpdater + SettingDeleter + Clone + 'static,
    >(
        v: T,
    ) -> Self {
        SettingOperations {
            view: Some(settings_wrap(v.clone())),
            create: Some(settings_wrap(v.clone())),
            update: Some(settings_wrap(v.clone())),
            delete: Some(settings_wrap(v)),
        }
    }
}
